#+title: Compare the different methods

Here I will compare 3 methods of filling missing data of FITS files.

 1. Astropy's Convolution
 2. Python's Maskfill method
 3. R-INLA

* Callable functions

#+name: threshold
#+begin_src python :results table
import numpy as np
threshold = np.arange(0,50,10)
return threshold
#+end_src

#+RESULTS: threshold
| 0 | 10 | 20 | 30 | 40 |

#+name: filling
#+begin_src python :results drawer output :var path = "astropy_conv" title="Astropy's Convolution" threshold = threshold :eval no
import matplotlib.pyplot as plt
import numpy as np
from astropy.io import fits
from astropy.visualization import astropy_mpl_style


fig, axes = plt.subplots(3, 5, figsize=(20, 12))  # Adjust the number of subplots as needed

# Iterate over different thresholds
for idx, i in enumerate(threshold):
    filename = "{}/filled_{}.fits".format(path,i)

    # Load the image data
    img_data_filled = fits.getdata(filename)

    # Plot the image
    ax = axes[1,idx]
    im = ax.imshow(img_data_filled, cmap='viridis', origin='lower', vmin=-2.0, vmax=20.0)
    ax.set_title("Threshold {}".format(i))
    plt.colorbar(im, ax=ax, orientation='vertical', label='Intensity')
######### Iterate over different thresholds for the second row of subplots
    filename = "galactic_center_masked_{}.fits".format(i)

    # Load the image data
    img_data_masked = fits.getdata(filename)

    # Plot the image on the second row
    ax = axes[0, idx]
    im = ax.imshow(img_data_masked, cmap='viridis', origin='lower', vmin=-2.0, vmax=20.0)
    plt.colorbar(im, ax=ax, orientation='vertical', label='Intensity')

######### Iterate over different diffs for the third row of subplots
    filename = "{}/diffs_{}.fits".format(path,i)

    # Load the original image data
    original = fits.getdata("galactic_center.fits")

    img_diffs = ((original - img_data_filled)/original)*100

    # Plot the image on the second row
    ax = axes[2, idx]
    im = ax.imshow(img_diffs, cmap='viridis', origin='lower', vmin=-2.0, vmax=20.0)
    ax.set_title("Diff = (Original - Filled({}))/Original %".format(i))
    plt.colorbar(im, ax=ax, orientation='vertical', label='Intensity')
######### Save the Diffs
    hdu = fits.PrimaryHDU(img_diffs)

    hdu.writeto(filename,overwrite = True)

# Adjust layout and display the figure
fig.suptitle("{}".format(title))
plt.tight_layout()
filename = "visualizations/{}".format(title)
plt.savefig(filename)
plt.close()

print("[[./"+filename+".png]]")
#+end_src

#+name: comparison
#+begin_src python :results value table :return df :var path = "" :eval no
import numpy as np
from skimage.metrics import structural_similarity as ssim
from astropy.io import fits
import pandas as pd
import matplotlib.pyplot as plt

# Load the FITS images for the masked images
masked_images = [fits.getdata('{}/filled_{}.fits'.format(path,i)) for i in np.arange(0, 50, 10)]

# Load the corresponding original images
original_images = fits.getdata(f'galactic_center.fits')

filel = "galactic_center.fits"

# Calculate MSE and SSIM for each comparison
mse_values = [np.mean((original_images - masked_images[i]) ** 2) for i in range(len(masked_images))]
ssim_values = [ssim(original_images, masked_images[i], data_range=original_images.max() - original_images.min()) for i in range(len(masked_images))]

# Create a DataFrame to store the results
data = {'Comparison': np.arange(0, 50, 10),
        'MSE': mse_values,
        'SSIM': ssim_values}
df = pd.DataFrame(data)

#+end_src


#+name:vis
#+begin_src python :results drawer output :var filename="galactic_center.fits" name="name" :exports results
import matplotlib.pyplot as plt
import numpy as np
from astropy.io import fits
from astropy.visualization import astropy_mpl_style


def vis(filename, name):

    hdul = fits.open(filename)

    data = hdul[0].data
    hdul.close()
    fname = "./visualizations/" + name + ".png"
    plt.style.use(astropy_mpl_style)

    plt.imshow(data, cmap="viridis", origin='lower', vmin=-2.0, vmax=20.0,)

    plt.title(name)
    plt.colorbar(orientation='vertical',label='Intensity')
    plt.savefig(fname)
    plt.close()
    return print("[["+fname+"]]")

vis(filename, name)
#+end_src

#+RESULTS: vis
:results:
[[./visualizations/name.png]]
:end:

* The files

** The astropy data

I will use the data from data.astropy.org. The reason for this is that we have a dense non homogeneous image and it will be good for testing

#+begin_src python :session masking :results output
import matplotlib.pyplot as plt
import numpy as np
from astropy.convolution import Gaussian2DKernel, convolve
from astropy.io import fits
from astropy.utils.data import get_pkg_data_filename
from scipy.ndimage import convolve as scipy_convolve

# Load the data from data.astropy.org
filename = get_pkg_data_filename('galactic_center/gc_msx_e.fits')
hdul = fits.open(filename)

hdul.info()
data = hdul[0].data

zoom = data[50:90, 60:100] * 1e5


hdul_1 = fits.PrimaryHDU(zoom)
hdul_1.writeto("galactic_center.fits",overwrite = True)

hdul.close()
#+end_src

#+RESULTS:
: Filename: /home/dp/.astropy/cache/download/url/b411ba5069b9fe8a0c38f5fd2c6b365d/contents
: No.    Name      Ver    Type      Cards   Dimensions   Format
:   0  PRIMARY       1 PrimaryHDU      24   (149, 149)   float64


Scale the file to have reasonable numbers (this is mostly so that colorbars do not have too many digits). Also, we crop it so you can see individual pixels

Then we can mask it by setting the brightest pixels to NaN

#+begin_src python :session masking :results file :var threshold = threshold
for i in threshold:
    img = zoom.copy()
    if i > 0:
        img[img > i] = np.nan
    hdu = fits.PrimaryHDU(img)
    filename = "galactic_center_masked_{}.fits".format(i)
    hdu.writeto(filename,overwrite = True)


ig, axes = plt.subplots(1, len(threshold), figsize=(20, 4))  # Adjust the number of subplots as needed

# Iterate over different thresholds
for idx, i in enumerate(np.arange(0, 50, 10)):
    filename = "galactic_center_masked_{}.fits".format(i)

    # Load the image data
    img_data = fits.getdata(filename)

    # Plot the image
    ax = axes[idx]
    im = ax.imshow(img_data, cmap='viridis', origin='lower', vmin=-2.0, vmax=20.0)
    ax.set_title("Threshold {}".format(i))
    plt.colorbar(im, ax=ax, orientation='vertical', label='Intensity')

# Adjust layout and display the figure
plt.tight_layout()
filename = "visualizations/masked_fits"
plt.savefig(filename)
plt.close()

filename+".png"
#+end_src

#+RESULTS:
[[file:visualizations/masked_fits.png]]



* Astropy Convolution


#+begin_src python :session astropy_convolution :results none
import numpy as np
import matplotlib.pyplot as plt
from astropy.convolution import Gaussian2DKernel, convolve
from astropy.io import fits
from scipy.ndimage import convolve as scipy_convolve
import os

mypath = "astropy_conv"

if not os.path.exists(mypath):
    os.mkdir(mypath)

#+end_src

We smooth with a Gaussian kernel with x_stddev=1 (and y_stddev=1). It is a 9x9 array.
Astropy's convolution replaces the NaN pixels with a kernel-weighted interpolation from their neighbors

#+begin_src python :session astropy_convolution :results none :var threshold=threshold
for i in threshold:
    data = fits.open("galactic_center_masked_{}.fits".format(i))[0].data

    kernel = Gaussian2DKernel(x_stddev=1)
    astropy_conv = convolve(data, kernel)

    hdu = fits.PrimaryHDU(astropy_conv)

    hdu.writeto("astropy_conv/filled_{}.fits".format(i),overwrite = True)
#+end_src



#+call: filling[:eval yes](path = "astropy_conv", title="Astropy's Convolution")

#+RESULTS:
:results:
[[./visualizations/Astropy's Convolution.png]]
:end:

#+call: comparison[:eval yes](path = "astropy_conv")

#+RESULTS:
|   | Comparison |               MSE |               SSIM |
|---+------------+-------------------+--------------------|
| 0 |        0.0 | 41.31836383457224 | 0.9542151726989633 |
| 1 |       10.0 | 175.0253853352854 | 0.8284485435865382 |
| 2 |       20.0 | 156.0987621112356 | 0.8674916390963295 |
| 3 |       30.0 | 146.6109666965225 | 0.8866031019110286 |
| 4 |       40.0 | 135.1704353934664 | 0.9033264570664562 |

** Astropy Fast Fourier Transform (FFT).

This is much more efficient for larger kernels.
#+begin_src python :session astropy_convolution :results none
import numpy as np
import matplotlib.pyplot as plt
from astropy.convolution import Gaussian2DKernel, convolve_fft
from astropy.io import fits
from scipy.ndimage import convolve as scipy_convolve
import os

mypath = "astropy_fft"

if not os.path.exists(mypath):
    os.mkdir(mypath)

for i in threshold:
    data = fits.open("galactic_center_masked_{}.fits".format(i))[0].data

    kernel = Gaussian2DKernel(x_stddev=1)
    astropy_conv = convolve(data, kernel)

    hdu = fits.PrimaryHDU(astropy_conv)

    hdu.writeto("astropy_fft/filled_{}.fits".format(i),overwrite = True)
#+end_src



#+call: filling[:eval yes](path = "astropy_fft", title="Astropy's FFT Convolution")

#+RESULTS:
:results:
[[./visualizations/Astropy's FFT Convolution.png]]
:end:


#+call: comparison[:eval yes](path = "astropy_ftt")

#+RESULTS:
|   |

* Python Maskfill

#+begin_src python :session maskfill
import subprocess

def run_poetry_command(command):
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout
        else:
            return result.stderr
    except Exception as e:
        return str(e)

# Example: Install dependencies
install_command = "poetry install"
install_output = run_poetry_command(install_command)
print(install_output)

# Example: Add a package
add_command = "poetry add package_name"
add_output = run_poetry_command(add_command)
print(add_output)

# Example: Run a Python script using Poetry
run_script_command = "poetry run python my_script.py"
run_script_output = run_poetry_command(run_script_command)
print(run_script_output)


#+end_src

#+RESULTS:
: None

#+begin_src python :session maskfill :results none :var x = threshold
from astropy.io import fits
import numpy as np
from maskfill import maskfill #download from github NOT pip
import matplotlib.pyplot as plt
from astropy.visualization import astropy_mpl_style

for i in x:
    hdul = fits.open("galactic_center_masked_{}.fits".format(i))
    # Get the data from the FITS file
    data = hdul[0].data

    # Create a masked array from the data, masking NaN values
    masked_data = np.ma.masked_invalid(data)

    # Access the mask array
    mask_array = masked_data.mask

    maskfill.maskfill(data, mask_array,writesteps=False,output_file='maskfilled/filled_{}.fits'.format(i),verbose=True)

#+end_src


#+call: filling[:eval yes](path = "maskfilled", title="Maskfill")

#+RESULTS:
:results:
[[./visualizations/Maskfill.png]]
:end:

#+call: comparison[:eval yes](path = "maskfilled")

#+RESULTS:
|   | Comparison |                MSE |               SSIM |
|---+------------+--------------------+--------------------|
| 0 |        0.0 |                0.0 |                1.0 |
| 1 |       10.0 | 169.59955577168992 | 0.8406528055948019 |
| 2 |       20.0 | 150.39562244550564 | 0.8853538258497918 |
| 3 |       30.0 | 140.01027954791735 | 0.9101794531835622 |
| 4 |       40.0 | 125.39866935548982 | 0.9334534610339772 |

* R-INLA

#+begin_src python :results none
import os

mypath = "r-inla"

if not os.path.exists(mypath):
    os.mkdir(mypath)

#+end_src

#+begin_src R :var threshold=threshold :results output
# Load necessary packages
library(INLA)
library(IDPmisc)
require(rasterVis)
library(viridis)
library(latex2exp)
library(fields) #;library(imager);
library(lattice);require(latticeExtra) #;require(INLAutils)
require(classInt);require(reshape2)
library(FITSio)
library(magrittr) # for %>% pipe operator

# Define threshold matrix from Python
thres <- threshold
source(paste("./inla_fct.R",sep=''))

# Read fits image
fits <- readFITS("galactic_center.fits")
img <- fits$imDat[,]
dims <- dim(img)
#dims <- dim(img)
cutoff = 0.9
# Access data from the first HDU
num_rows_thres <- 1:nrow(thres)

print(num_rows_thres)  # Check the values of num_rows_thres

# Iterate over the rows of the thres matrix
for (j in num_rows_thres) {
  i = thres[j,1]
        filename <- sprintf("galactic_center_masked_%d", i)
        fits_file <- readFITS(file=paste(filename,"fits",sep='.'))
        img <- fits$imDat[,]
        dims <- dim(img)
        # Create x and y arrays using matrix indexing
        x <- matrix(rep(1:dims[1], dims[2]), nrow = dims[1], ncol = dims[2])
        y <- matrix(rep(1:dims[2], each = dims[1]), nrow = dims[1], ncol = dims[2])

        valid <- which(!(is.na(img)))

        xsize <- dims[2]
        ysize <- dims[1]
        xfin <- xsize
        yfin <- ysize
        logimg = log10(img)

      #  imginla <- stationary_inla(x[valid],y[valid],logimg[valid], zoom = 1,
       #                         xsize=xsize,shape='none',xfin=xfin,
        #                        yfin=yfin,ysize=ysize,cutoff=cutoff,
         #                       tolerance=1e-6,restart=0)
  imginla <- nonparametric_inla(x,y,logimg, xsize = xsize, ysize = ysize, tepar = "NaN", weight = 1)
        writeFITSim(imginla$outsd,file=sprintf("r-inla/filled_%d.fits",i))
}

#+end_src


#+call: vis[:var filename = "./r-inla/filled_30.fits"]

#+RESULTS:
:results:
[[./visualizations/name.png]]
:end:

* Comparisons

1. **Mean Squared Error (MSE)**:
   - Mean Squared Error is a commonly used metric to measure the average squared difference between the original and the masked images. It quantifies the average of the squares of the errors or deviations. A lower MSE value indicates a closer resemblance between the two images.
   - The formula for MSE between two images A and B, each with dimensions \(m \times n\), is:

     \[
     MSE = \frac{1}{mn} \sum_{i=0}^{m-1} \sum_{j=0}^{n-1} (A_{ij} - B_{ij})^2
     \]

2. **Structural Similarity Index (SSIM)**:
   - SSIM is a perception-based metric that measures the similarity between two images. It considers luminance, contrast, and structure. Unlike MSE, SSIM takes into account the structure of the images, making it more suitable for assessing perceptual differences.
   - The SSIM index ranges from -1 to 1, where 1 indicates perfect similarity. Typically, a value above 0.9 is considered a good match.
   - The SSIM index formula involves comparisons between local neighborhoods of the images' pixels. The formula for SSIM index between images A and B is:

     \[
     SSIM(A, B) = \frac{(2 \mu_A \mu_B + C_1)(2 \sigma_{AB} + C_2)}{(\mu_A^2 + \mu_B^2 + C_1)(\sigma_A^2 + \sigma_B^2 + C_2)}
     \]

     Here,
     - \(\mu_A\) and \(\mu_B\) are the means of images A and B,
     - \(\sigma_A^2\) and \(\sigma_B^2\) are the variances of images A and B,
     - \(\sigma_{AB}\) is the covariance of images A and B,
     - \(C_1\) and \(C_2\) are small constants to prevent division by zero errors and stabilize the division, and
     - \(L\) is the dynamic range of pixel values (typically \(2^{\text{bitdepth}} - 1\) for images with bit depth).


** Astropy conv
#+call: comparison[:eval yes](path = "astropy_conv")

#+RESULTS:
|   | Comparison |               MSE |               SSIM |
|---+------------+-------------------+--------------------|
| 0 |        0.0 | 41.31836383457224 | 0.9542151726989633 |
| 1 |       10.0 | 175.0253853352854 | 0.8284485435865382 |
| 2 |       20.0 | 156.0987621112356 | 0.8674916390963295 |
| 3 |       30.0 | 146.6109666965225 | 0.8866031019110286 |
| 4 |       40.0 | 135.1704353934664 | 0.9033264570664562 |

** Astropy fft
#+call: comparison[:eval yes](path = "astropy_fft")

#+RESULTS:
|   | Comparison |               MSE |               SSIM |
|---+------------+-------------------+--------------------|
| 0 |        0.0 | 41.31836383457224 | 0.9542151726989633 |
| 1 |       10.0 | 175.0253853352854 | 0.8284485435865382 |
| 2 |       20.0 | 156.0987621112356 | 0.8674916390963295 |
| 3 |       30.0 | 146.6109666965225 | 0.8866031019110286 |
| 4 |       40.0 | 135.1704353934664 | 0.9033264570664562 |

** Maskfill
#+call: comparison[:eval yes](path = "maskfilled")

#+RESULTS:
|   | Comparison |                MSE |               SSIM |
|---+------------+--------------------+--------------------|
| 0 |        0.0 |                0.0 |                1.0 |
| 1 |       10.0 | 169.59955577168992 | 0.8406528055948019 |
| 2 |       20.0 | 150.39562244550564 | 0.8853538258497918 |
| 3 |       30.0 | 140.01027954791735 | 0.9101794531835622 |
| 4 |       40.0 | 125.39866935548982 | 0.9334534610339772 |
